#include <iostream>
#include <cstdlib>

using namespace std;

#define KEY_TOTAL_LENGTH 60

// s盒
short sBox[16][16] = {
        {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
        {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
        {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},
        {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},
        {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},
        {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},
        {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},
        {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},
        {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},
        {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},
        {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},
        {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},
        {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},
        {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},
        {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},
        {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}
};
// 逆s盒
short sBoxInverse[16][16] = {
        {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},
        {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},
        {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},
        {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},
        {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},
        {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},
        {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},
        {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},
        {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},
        {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},
        {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},
        {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},
        {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},
        {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},
        {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},
        {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}
};
short mixColumnMat[4][4] = {
        {2, 3, 1, 1},
        {1, 2, 3, 1},
        {1, 1, 2, 3},
        {3, 1, 1, 2}
};
short mixColumnMatDecrypt[4][4] = {
        {0xe, 0xb, 0xd, 0x9},
        {0x9, 0xe, 0xb, 0xd},
        {0xd, 0x9, 0xe, 0xb},
        {0xb, 0xd, 0x9, 0xe}
};
short message[4][4];
short key[4][KEY_TOTAL_LENGTH];
short rcon[7] = {1, 2, 4, 8, 16, 32, 64};

// 从s盒取数据，flag: 1->encrypt, 0->decrypt
short getDataFromSBox(short n, int flag) {
    // 若flag为1则从s-盒取数据，否则从逆s-盒取数据
    if (flag) return sBox[n >> 4][n & 0xf];
    else return sBoxInverse[n >> 4][n & 0xf];
}

// 输入明文至二维short数组message
short inputMessage() {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            cin >> hex >> message[j][i];
        }
    }
}

// 处理输入的密钥，使用4*60的二维short数组key的前8列存储原始密钥
void inputKey() {
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 4; j++) {
            cin >> hex >> key[j][i];
        }
    }
}

// 产生子密钥，KEY_TOTAL_LENGTH为60
void genSubKey() {
    for (int i = 8; i < KEY_TOTAL_LENGTH; i++) {
        if (i % 8 == 0) {
            for (int j = 0; j < 4; j++) {
                key[j][i] = key[j][i - 8] ^ getDataFromSBox(key[(j + 1) % 4][i - 1], 1);
            }
            key[0][i] ^= rcon[(i - 8) / 8];
        } else if (i % 8 && (i - 4) % 8 == 0) {
            for (int j = 0; j < 4; j++) {
                key[j][i] = key[j][i - 8] ^ getDataFromSBox(key[j][i - 1], 1);
            }
        } else if (i % 8 && (i - 4) % 8) {
            for (int j = 0; j < 4; j++) {
                key[j][i] = key[j][i - 8] ^ key[j][i - 1];
            }
        }
    }
}

// 轮密钥加
void addRoundKey(int round) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            message[i][j] ^= key[i][round * 4 + j];
        }
    }
}

// 字节代换，flag: 1->encrypt, 0->decrypt
void byteSub(int flag) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            message[i][j] = getDataFromSBox(message[i][j], flag);
        }
    }
}

// 行移位，flag: 1->encrypt, 0->decrypt
void shiftRow(int row, int flag) {
    // 实际需要左移位的字节数
    int dRow = row;
    // 逆行移位时，右移i字节相当于行移位中的左移4-i字节
    if (flag == 0) dRow = 4 - row;
    short tmp[4];
    for (int i = 0; i < 4; i++) tmp[i] = message[row][i];
    for (int i = 0; i < 4; i++) message[row][i] = tmp[(i + dRow) % 4];
}

// 基础乘2操作
short basicGFMul(short s) {
    if (s & 0x80) return ((s << 1) ^ 0x1b) & 0xff;
    else return s << 1;
}

// 乘法操作
short GFMul(short s, short m) {
    short prime = m % 2;
    m -= prime;
    short ans = 0, base = 8;
    while (m) {
        if (m >= base) {
            short tmpAns = s, tmp = base;
            while (tmp / 2) {
                tmpAns = basicGFMul(tmpAns);
                tmp /= 2;
            }
            m -= base;
            ans ^= tmpAns;
        }
        base /= 2;
    }

    if (prime) ans ^= s;

    return ans;
}

// 列混合，flag: 1->encrypt, 0->decrypt
void mixColumn(int flag) {
    short newMes[4][4];
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            newMes[i][j] = 0;
            for (int k = 0; k < 4; k++) {
                // 根据flag值的不同，与不同的矩阵进行相乘
                if (flag)
                    newMes[i][j] ^= GFMul(message[k][j], mixColumnMat[i][k]) & 0xff;
                else
                    newMes[i][j] ^= GFMul(message[k][j], mixColumnMatDecrypt[i][k]) & 0xff;
            }
        }
    }

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            message[i][j] = newMes[i][j];
        }
    }
}

// AES encrypt
void aesEncrypt() {
    addRoundKey(0);
    for (int i = 1; i <= 14; i++) {
        // 字节代换
        byteSub(1);
        // 行移位
        for (int row = 1; row <= 3; row++) {
            shiftRow(row, 1);
        }
        // 列混合（最后一轮不进行此操作）
        if (i != 14) mixColumn(1);
        // 轮密钥加
        addRoundKey(i);
    }
}

// AES decrypt
void aesDecrypt() {
    addRoundKey(14);
    for (int i = 13; i >= 0; i--) {
        // 逆行移位
        for (int row = 1; row <= 3; row++) {
            shiftRow(row, 0);
        }
        // 逆字节代换
        byteSub(0);
        // 轮密钥加
        addRoundKey(i);
        // 逆列混合（最后一轮不进行此操作）
        if (i) mixColumn(0);
    }
}

// 输出加密或解密后的内容
void outputMessage(){
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            if (message[j][i] < 16) cout << 0;
            cout << hex << message[j][i] << ' ';
        }
    }
    cout << endl;
}

int main() {
    cout << "请输入需要加密或者解密的消息：\n";
    cout << "（以十六进制格式输入，消息格式如00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff）\n";
    inputMessage();

    cout << "\n请输入256位密钥：\n";
    cout << "（以十六进制格式输入，密钥格式如00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f）\n";
    inputKey();
    genSubKey();

    int op;
    cout << "\n请输入你要进行的操作：（1代表加密，0代表解密）\n";
    cin >> op;

    if (op) {
        aesEncrypt();
        cout << "\n加密后的结果是：\n";
    }
    else {
        aesDecrypt();
        cout << "\n解密后的结果是：\n";
    }

    outputMessage();
    system("pause");
    return 0;
}

/*
00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff
00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f
密文：8e a2 b7 ca 51 67 45 bf ea fc 49 90 4b 49 60 89
-----------------------------------------------------------------------------------------------------
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34
30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35 30 31 32 33 34 35 36 37 38 39 30 31 32 33 34 35
第 01 轮输出：83 2c f6 38 79 7a c2 43 df 17 fc 2f 30 6b 60 7d
第 02 轮输出：0b 5e f3 b0 6d 3d 66 c8 00 99 e9 a6 67 8a 96 51
第 03 轮输出：8b e0 fa e8 69 f4 4f cd d6 1a 80 0e ab 0d 47 91
第 04 轮输出：27 dc c8 52 22 93 77 66 f6 f9 c4 d5 ec e1 83 e2
第 05 轮输出：76 96 df e1 20 93 19 bc 7a c5 50 c4 93 eb 58 6e
第 06 轮输出：9a d1 ab 13 42 d3 44 4d d3 ca 4a 2f 58 ff df 88
第 07 轮输出：9b 6f 88 88 2e b8 9e 7b 48 cb 98 68 d4 df ab 88
第 08 轮输出：ee a0 e2 5d 41 7a 6e cd fb 11 1e 79 a6 2a 1f ed
第 09 轮输出：5e 59 a8 9e 59 2e 69 bf 65 b1 28 9d 7c 63 e3 cd
第 10 轮输出：ea 97 4f a3 f0 23 7d d6 61 bc 52 36 7d eb 95 6a
第 11 轮输出：44 d3 88 1c e0 8d ab 83 91 99 29 77 bc a5 63 09
第 12 轮输出：fa a3 19 4f 3c 00 11 c9 b7 d3 14 96 c7 27 a9 81
第 13 轮输出：34 29 98 e3 61 a9 82 c2 58 2a b2 dc ec 2b 9e 09
密文(第 14 轮输出)： 68 aa d3 6c 34 30 a3 bb 3d c1 c1 80 a9 48 fe f8
 */
